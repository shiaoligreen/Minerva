##DCT task#first partn = 8;A = zeros(i,j);for i = 1:n;  for j = 1:n;    A(i,j) = cos((i-1)*((j-0.5)/n)*pi);  endforendforA#normalisation Anorm = zeros(n,n);for i = 1:size(A,2);  norm(A(i,:));  col = A(i,:)/norm(A(i,:));  Anorm(:,i) = col;endforAnorm;#eigenvalueseig(Anorm)##code for first set of experiments, repeated for each imagepkg load imageA=imread("symmetric.jpeg");# Convert the original A image matrix to a single grayscale matrixA4 = rgb2gray(A);imshow(A4)# Display side-by-side (subplot) color and grayscale pics of paella.# Subplot divides the matlab figure into a matrix. In this example is# matrix with 1-row and 2 columns : 1 : 2 :  The last parameter in # the subplot command, is the element # in the array.  In this case# element #1 is the color picture matrix A, element #2 is matrix A4.subplot(1,2,1), imshow(A);title("Original Color Image");subplot(1,2,2), imshow(A4);title("Grayscale Image from Color Image");# Convert the image matrix elements from integers(uint8) to double# precision floating point numbers.  This is necessary to perform any # Linear Algebra operations on the image dataA4d = im2double(A4);# The command who analyzes the data type and storage usewhos# Data Compression: Dimension Reduction.# Step 1: Compute SVD of A4d (the matrix with floating point vals)[U,S,V] = svd(A4d);# Obtain the dimensions of the image matrix. [m,n] = size(A4d);# Step 2: Use the command diag to get the elements in diagonal( S ) svs = diag(S);# In a pixel-base image, the dominant singular values contribute a # lot more information to the picture definition than the smaller # singular values.  In the next experiment, you will generate# different images using only a subset of the larger singular values.  # For this, we compute approximation to A with matrices Ak, where k # is the number of singular values from the original matrix that we# decide to keep at every comparative experiment. Recall the Eq.4.49 # Wi = Sum_i=1 ^k (\sigma_i*u_i*v_i^T), where k < n# Step 3: In order to inspect the singular values of A4d, we plot the# singular values of A4d. semilogy sets a logarithmic base in y-axis.semilogy(svs);# Step 4: Conduct the experiment for different number of singular # values; k = 10, 50, 100, 300, and 600. The resulting matrix # approximation from every experiment is stored in a 2x2 matrix, the # third dimension of W.  We will have 6 cases in this experiment. Wk = zeros( m, n, 6);k1 = 1;# Main loop for 6 experiment cases varying the values of k.for k = [10, 50, 100, 200, 300, 600]  # Implementing equation 4.49. Selecting only k-singular vals.  W(:,:,k1) = U(:,1:k)*S(1:k, 1:k)*V(:,1:k)';  k1 += 1;endfor# Step 5: to help us in our analysis of the memory complexity and# image quality, we first  obtain the memory size requirements# to store A4d with the command sizeof, At every experiment we will# compare this against the sizeof(U+S+V). To analyze the image # quality, we display the resulting compressed images using the # subplot command and compute the relative error as before.# These commands print out the memory savings and displays the # images.sa4 = sizeof(A4d);printf("Required memory for original matrix: %6.3f Mbytes\n",        sa4/1e6);# Printing report from computational accuracy and spatial complexity# (memory requirement) analysis. k1 = 1;nA4d = norm(A4d);for k = [10, 50, 100, 200, 300, 600]    su=sizeof(U(:,1:k)); sv=sizeof(V(:,1:k)); ss= sizeof(S(1:k,1:k));  printf("Savings(%6.3f) \n",((sa4-(su+sv+ss))/sa4)*100)  imgerr = norm(A4d-W(:,:,k1))/nA4d;  printf("The rel. error in reconstruction image with k=%d is %e\n",k,imgerr);  k1 += 1;endfor##code for second set of experiments, just for asymmetric imageA=imread("asymmetric.jpeg");A1 = A(:,:,1); # The first 2D matrix in A has red color infoA2 = A(:,:,2); # The second 2D matrix in A has green color infoA3 = A(:,:,3); # The last 2D matrix in A has blue color infoA1d = im2double(A1);[U1,S1,V1] = svd(A1d);A2d = im2double(A2);[U2,S2,V2] = svd(A2d);A3d = im2double(A3);[U3,S3,V3] = svd(A3d);k1 = 100k2 = 100k3 = 100W1 = U1(:,1:k1)*S1(1:k1, 1:k1)*V1(:,1:k1)';W2 = U2(:,1:k2)*S2(1:k2, 1:k2)*V2(:,1:k2)';W3 = U3(:,1:k3)*S3(1:k3, 1:k3)*V3(:,1:k3)';rgbImage = cat(3, W1, W2, W3);subplot(3,3,8), imshow(A);title(sprintf("R k = %d, G k = %d, B k = %d", k1, k2, k3))